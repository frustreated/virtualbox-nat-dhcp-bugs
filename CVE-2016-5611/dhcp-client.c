/*
 * Simple DHCP Client
 * License : BSD
 * Author : Samuel Jacob (samueldotj@gmail.com)
 */

#include "dhcp-client.h"

extern pcap_t *pcap_handle;

/*
 * Get MAC address of given link(dev_name)
 */
int
get_mac_address(char *dev_name, u_int8_t *mac)
{
	struct ifreq s;
	int fd = socket(PF_INET, SOCK_DGRAM, IPPROTO_IP);
	int result;

	memset((void *)&s, 0, sizeof(struct ifreq));
	strcpy(s.ifr_name, dev_name);
	result = ioctl(fd, SIOCGIFHWADDR, &s);
	close(fd);
	if (result != 0)
		return -1;

	memcpy((void *)mac, s.ifr_addr.sa_data, 6);
	return 0;
}

/*
 * Return checksum for the given data.
 * Copied from FreeBSD
 */

unsigned short
in_cksum(unsigned short *addr, int len)
{
	register int sum = 0;
	u_short answer = 0;
	register u_short *w = addr;
	register int nleft = len;
	/*
	 * Our algorithm is simple, using a 32 bit accumulator (sum), we add
	 * sequential 16 bit words to it, and at the end, fold back all the
	 * carry bits from the top 16 bits into the lower 16 bits.
	 */
	while (nleft > 1)
	{
		sum += *w++;
		nleft -= 2;
	}
	/* mop up an odd byte, if necessary */
	if (nleft == 1)
	{
		*(u_char *)(&answer) = *(u_char *) w;
		sum += answer;
	}
	/* add back carry outs from top 16 bits to low 16 bits */
	sum = (sum >> 16) + (sum & 0xffff);     /* add hi 16 to low 16 */
	sum += (sum >> 16);             /* add carry */
	answer = ~sum;              /* truncate to 16 bits */
	return (answer);
}

/*
 * Ethernet output handler - Fills appropriate bytes in ethernet header
 */

void
ether_output(u_char *frame, u_int8_t *mac, int len)
{
	int result;
	struct ether_header *eframe = (struct ether_header *)frame;

	memcpy(eframe->ether_shost, mac, ETHER_ADDR_LEN);
	memset(eframe->ether_dhost, -1,  ETHER_ADDR_LEN);
	eframe->ether_type = htons(ETHERTYPE_IP);

	len = len + sizeof(struct ether_header);

	/* Send the packet on wire */
	result = pcap_inject(pcap_handle, frame, len);
	if (result <= 0)
		pcap_perror(pcap_handle, "ERROR:");
}

/*
 * IP Output handler - Fills appropriate bytes in IP header
 */

void
ip_output(struct ip *ip_header, int *len)
{
	*len += sizeof(struct ip);

	ip_header->ip_hl = 5;
	ip_header->ip_v = IPVERSION;
	ip_header->ip_tos = 0x10;
	ip_header->ip_len = htons(*len);
	ip_header->ip_id = htons(0xffff);
	ip_header->ip_off = 0;
	ip_header->ip_ttl = 16;
	ip_header->ip_p = IPPROTO_UDP;
	ip_header->ip_sum = 0;
	ip_header->ip_src.s_addr = 0;
	ip_header->ip_dst.s_addr = 0xFFFFFFFF;

	ip_header->ip_sum = in_cksum((unsigned short *) ip_header, sizeof(struct ip));
}

/*
 * UDP output - Fills appropriate bytes in UDP header
 */
void
udp_output(struct udphdr *udp_header, int *len)
{
	if (*len & 1)
		*len += 1;
	*len += sizeof(struct udphdr);

	udp_header->uh_sport = htons(DHCP_CLIENT_PORT);
	udp_header->uh_dport = htons(DHCP_SERVER_PORT);
	udp_header->uh_ulen = htons(*len);
	udp_header->uh_sum = 0;
}

/*
 * DHCP output - Just fills DHCP_BOOTREQUEST
 */
void
dhcp_output(dhcp_t *dhcp, u_int8_t *mac, int *len)
{
    *len += sizeof(dhcp_t);
    memset(dhcp, 0, sizeof(dhcp_t));

    dhcp->opcode = DHCP_BOOTREQUEST;
    dhcp->htype = DHCP_HARDWARE_TYPE_10_EHTHERNET;
    dhcp->hlen = 6;
    memcpy(dhcp->chaddr, mac, DHCP_CHADDR_LEN);

    dhcp->magic_cookie = htonl(DHCP_MAGIC_COOKIE);
}

/*
 * Adds DHCP option to the bytestream
 */
int
fill_dhcp_option(u_int8_t *packet, u_int8_t code, u_int8_t *data, u_int8_t len)
{
	packet[0] = code;
	packet[1] = len;
	memcpy(&packet[2], data, len);

	return len + (sizeof(u_int8_t) * 2);
}
